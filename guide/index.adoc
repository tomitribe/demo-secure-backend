:encoding: UTF-8
:linkattrs:
:sectlink:
:sectanchors:
:sectid:
:imagesdir: media

= Secure backend with the Tribestream API Gateway

== Introduction

=== Time
10 minutes

=== Learning objectives
* Secure the access to multiple backend microservices.
* Understand the difference between user (people) and client (software) accounts.
* How Security Profiles, API connections, User Accounts, Client Accounts and Routes work together.

=== Prerequisites
* Docker installed and the daemon is running on your computer.
* Git command line tool.
* *This is an advanced guide.* It's helpful if you have seen already the following guides:
** Quickstart
** Secure Microservices with OAuth 2.0 & JWT
** Route Services with mod_rewrite

== The Architecture
We have one important requirement: *All* HTTP requests must be authenticated.

This means the HTTP requests for both the frontend users and the backend services will be authenticated.

We are using 2 backend services.

=== Why backend authentication?
A significant number of organizations simply assume the intranet where the backend services are running is secure.
With that in mind, they usually don't require authentication between services.
Services can call each other without limitations.

What if someone gains access to that intranet and is able to query all the REST APIs without limitations?
There are a few famous data breaches that were performed by employees or contractors.

What about IP whitelisting?
Someone from the outside, exploiting a vulnerability, can gain access to a trusted machine, leading also to data breaches.

image::no-backend-security.png[title="No Backend Authentication"]

In parallel to these attack vectors, as organizations grow, and you keep increasing the number of services and developer teams, you will want to keep an eye on how's executing which services and why.
You want to keep track on who's generating more load and even disable a particular service.

In this example we assume the organization isolates all the services.
All requests must go trough the API gateway.
There is merit in centralising credentials management.
Imagine what you have an environment with 10 microservices and you add a new one used by half of them...
You need to propagate your credentials through 5 different teams.
The more people have access to the credentials, the higher the chance of a breach.

To each service, two sets of credentials will be given:
* Inbound credentials for the received requests.
* Outbound credentials for all requests that service needs to perform.

No one, apart from the TAG and a particular service, will know the credentials. If at some point a misbehaved microservice needs to be isolated by the support team, because it has a bug doing calls in a loop, you can immediately disable its credentials.

To wrap it up, we need backend authentication because:
* The intranet is not that secure.
* HTTP requests can only bee processed from authenticated sources.
* We can revoke access to misbehaved microservices at any time.

=== Our setup
Remember the Movie application from previous guides? It turns out that we were asked to split it...
For some super clever reason we had to extract the ratings into a separated microservice.

Now we have the _movie-back_ and the _ratings-app_ microservices.
The _movie-back_ will need, from now on, to do an HTTP request to the _ratings-app_ to know the rating of each movie.

Frontend users will still see it as _movie_ and will need to use OAuth 2.0 authentication.

The requests are then forward to the _movie-back_ microservice using Basic authentication. In order to call the _ratings_app_ we also need to use Basic authentication, and remember, ony the TAG knows the credentials of all the microservices.

image::architecture.png[title="Our Architecture"]

An additional architectural advantage of having the TAG, but we are not showing today is that the endpoints are normalised and resilient to changes. The endpoints of the microservices themselves can change without impacting who's using them.

=== Much more
In this case we are using Basic authentication without HTTPS. Don't do that in production.

Basic authentication cannot prevent replay attacks.

Ideally, the backed requests should be secured using HTTP Signatures. We are not doing in this guide to keep the client applications simpler. If you haven't seen it yet, take a look at the HTTP Signatures guide.

== The Demo

=== Start the Tribestream API Gateway (TAG)
On another terminal execute the following command according to your operating system:

We can reuse the TAG docker container we created from the Tribe quickstart guide. To start TAG execute the following command:
```
docker start tag
```
If this is the first time you run TAG, open a terminal execute the following command according to your operating system:

For linux:
```
docker run --net="host" -de LICENSE=accept --name tag tomitribe/tribestream-api-gateway
```
For OsX:
```
docker run -de LICENSE=accept --name tag -p 8080:8080  tomitribe/tribestream-api-gateway
```
To see the TAG starting process log you can execute the following command:
```
docker logs -f tag
```

=== Open the TAG
Open a browser and navigate to: http://localhost:8080/tag

Login into the TAG dashboard using the following credentials:

* username:admin
* password:admin

image::loginGif.gif[title="TAG login and dashboard"]

=== Start the movie backend microservice
In order to run our demo Microservice we need to open a terminal and execute the following command:

If we already have used the movie-back:
```
docker start movie-back
```
For the first time:
```
docker run -d -p 9080:9080 --name movie-back  tomitribedev/movie-back
```
We can validate that our microservice is up and running by executing the following command:
```
curl -i http://localhost:9080/movie-back/api/movies
```
You must get a 401 error for unouthorized.

=== start the ratings app microservice
In order to run our demo Microservice we need to open a terminal and execute the following command:

If we already have used the ratings-app:
```
docker start ratings-app
```
For the first time:
```
docker run -d -p 9070:9070 --name ratings-app  tomitribedev/ratings-app
```
We can validate that our microservice is up and running by executing the following command:
```
curl -i http://localhost:9070/rating-app/api/ratings
```
You must get a 401 error for unouthorized.

=== Configure the TAG
We are going to add 2 user accounts, a client account, an OAuth 2.0 security profile, 2 API Connections and 2 routes to our microservices.
Please checkout this github project:
```
git clone https://github.com/tomitribe/demo-secure-backend.git
```
Change to the _demo-secure-backend_ folder:
```
cd demo-secure-backend
```
And execute this script for Linux:
```
./setup_data_linux.sh
```
Or this one for OsX or Windows:
```
./setup_data_osx.sh
```
The difference relates to how Docker sees the host computer network.


== Stop all

Since both the TAG and the microservice were created with a specific container name, you can now stop both containers, from the command line execute the following command.

Stopping TAG:OAuth 2.0

```
docker stop tag
```
Stopping the movie backend microservice:
```
docker stop movie-back
```


== That's it

Thanks for reading this guide.


















